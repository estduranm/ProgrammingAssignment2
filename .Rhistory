x<-0
}
x
x <- 1:10
if(x > 5) {
x<-TRUE
}
x <- 1:10
if(x > 5) {
x<-TRUE
} else {
x<-FALSE
}
y <- if(x > 5) {
x<-TRUE
} else {
x<-FALSE
}
y
x
x
x <- 1:10
x
if(x > 5) {
x<-TRUE
} else {
x<-FALSE
}
x
x <- 1:10
if(x>3){
y<-10
}else{
y<-0
}
y
?"if"
f <- function(x) {
g<- function(y) {
y+z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
f(3)
z <-4
f(3)
y
f <- function(x) {
g<- function(y) {
y+z
}
z <- 4
x + g(x)
f(3)
f <- function(x) {
g<- function(y) {
y+z
}
z <- 4
x + g(x)
f <- function(x) {
g <- function(y) {
y+z
}
z <-4
x + g(x)
}
directory = "/Users/Esteban/Desktop/specdata"
#get the file List in that directory
fileList <- list.files(directory)
#extract the file names and store as numeric for comparison
#the sub part: substitute the .csv in every name and just let the number
#the sub part arguments: sustituir \\.csv$", poner "" (en este caso esto es no poner nada), at fileList
#as.numeric: coercion in a number
fileNames <- as.numeric(sub("\\.csv$","",fileList))
#select files to be imported based on the user input or default
#the match part: find id en fileNames, prove using id %in% fileNames
#fileList[] part: subset in fileList where there is a match between id and fileNames
selected.files <- fileList[match(id,fileNames)]
#import data
#lapply: apply a function to all the variables in a data frame
#lapply: en el filepath, read all the csv included in selected.files
Data <- lapply(file.path(directory,selected.files),read.csv)
#convert into data frame
#do.call: rbind (rowbind) into a data frame, from al the subdata frames at Data
#do.call bind all the parts in one step
Data <- do.call(rbind.data.frame,Data)
complete <- function(directory, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
#get the file List in that directory
fileList <- list.files(directory)
#extract the file names and store as numeric for comparison
#the sub part: substitute the .csv in every name and just let the number
#the sub part arguments: sustituir \\.csv$", poner "" (en este caso esto es no poner nada), at fileList
#as.numeric: coercion in a number
fileNames <- as.numeric(sub("\\.csv$","",fileList))
#select files to be imported based on the user input or default
#the match part: find id en fileNames, prove using id %in% fileNames
#fileList[] part: subset in fileList where there is a match between id and fileNames
selected.files <- fileList[match(id,fileNames)]
#import data
#lapply: apply a function to all the variables in a data frame
#lapply: en el filepath, read all the csv included in selected.files
Data <- lapply(file.path(directory,selected.files),read.csv)
#convert into data frame
#do.call: rbind (rowbind) into a data frame, from al the subdata frames at Data
#do.call bind all the parts in one step
Data <- do.call(rbind.data.frame,Data)
complete <- function(directory, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
#get the file List in that directory
fileList <- list.files(directory)
#extract the file names and store as numeric for comparison
#the sub part: substitute the .csv in every name and just let the number
#the sub part arguments: sustituir \\.csv$", poner "" (en este caso esto es no poner nada), at fileList
#as.numeric: coercion in a number
fileNames <- as.numeric(sub("\\.csv$","",fileList))
#select files to be imported based on the user input or default
#the match part: find id en fileNames, prove using id %in% fileNames
#fileList[] part: subset in fileList where there is a match between id and fileNames
selected.files <- fileList[match(id,fileNames)]
#import data
#lapply: apply a function to all the variables in a data frame
#lapply: en el filepath, read all the csv included in selected.files
Data <- lapply(file.path(directory,selected.files),read.csv)
#convert into data frame
#do.call: rbind (rowbind) into a data frame, from al the subdata frames at Data
#do.call bind all the parts in one step
Data <- do.call(rbind.data.frame,Data)
data
Data
complete <- function(directory, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
complete <- function(directory, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
corr <- function(directory, threshold = 0) {
# note: NULL, NA, NaN are all place holders only and cannot be compared using logical operators.
# note: numeric(0) cannot be compared either, use length(numeric(0)) instead.
# note: when coercing a data frame into matrix, consider it's data class/type.
# note: for lists, pay attention to the difference between '[' &'[[' when subsetting!
# note: to return a certain value, just type the variable name at the end in the function.
# note: complete.cases() returns a logical vector.
# note: lapply(x, FUN, ...), the '...' can pass in the variables following the function.
#set the path
directory = "/Users/Esteban/Desktop/specdata"
## Store full path names to a  files (character vector) to read the files directly
files <- list.files(directory, full.names = TRUE)
# Store all the data to the list 'data'
data <- lapply(files, read.csv, header = TRUE)
#     valid_data <- lapply(data, function(x) x[!is.na(x$Date) & !is.na(x$sulfate) & !is.na(x$nitrate) & !is.na(x$ID),])
#     Store all complete cases in valid_data
valid_data <- lapply(data, function(x) x[complete.cases(x),])
if (is.null(valid_data) == TRUE){
numeric(0)
}
else {
correlations <- numeric(0)
# Initialize the data set that pass the threshold requirement
for (i in seq_along(valid_data)){
if (nrow(valid_data[[i]]) >= threshold){
correlations <- c(correlations, cor(valid_data[[i]]$sulfate, valid_data[[i]]$nitrate))
}
}
# Select the data frames which pass the threshold requirement
correlations
}
}
complete <- function(directory, id = 1:332) {
# note: read.csv() function needs the header parameter.
# note: is.na() function will force data frames into matrices.
# note: complete.cases() does exactly this.
# note: use sum() to count the number of TRUEs in a logical vector.
#set the path
directory = "/Users/Esteban/Desktop/specdata"
## Store full path names to a  files (character vector) to read the files directly
files <- list.files(directory, full.names = TRUE)
## Store all selected monitors' data to monitor_data (list)
## lapply: read all the .csv for each id on files
Data <- lapply(files[id], function(x) read.csv(x, header = TRUE))
## Count the number of rows which contain all 'TRUE' values.
## sapply: sum all the complete cases inside Data
nobs <- sapply(Data, function(x) sum(complete.cases(x)))
## Combine the two vectors into a data frame
data.frame('id' = id, 'nobs' = nobs)
}
source("corr.R")
source("complete.R")
cr <- corr("specdata", 150)
head(cr)
rm(cr)
mr(directory)
rm(directory)
rm(fileList)
rm(fileNames)
rm(complete)
directory = "/Users/Esteban/Desktop/specdata"
files <- list.files(directory, full.names = TRUE)
data <- lapply(files, read.csv, header = TRUE)
data
#     Store all complete cases in valid_data
valid_data <- lapply(data, function(x) x[complete.cases(x),])
valid_data
data
valid_data
if (is.null(valid_data) == TRUE){
numeric(0)
}
else {
correlations <- numeric(0)
if (is.null(valid_data) == TRUE){
numeric(0)
}
else {
correlations <- numeric(0)
}
examp <- numeric(0)
examp
if (is.null(valid_data) == TRUE){
numeric(0)
}
rm(examp)
examp <- if (is.null(valid_data) == TRUE){
numeric(0)
}
examp
pollutantmean <- function(directory, pollutant, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
#get the file List in that directory
fileList <- list.files(directory)
#extract the file names and store as numeric for comparison
#the sub part: substitute the .csv in every name and just let the number
#the sub part arguments: sustituir \\.csv$", poner "" (en este caso esto es no poner nada), at fileList
#as.numeric: coercion in a number
fileNames <- as.numeric(sub("\\.csv$","",fileList))
#select files to be imported based on the user input or default
#the match part: find id en fileNames, prove using id %in% fileNames
#fileList[] part: subset in fileList where there is a match between id and fileNames
selected.files <- fileList[match(id,fileNames)]
#import data
#lapply: apply a function to all the variables in a data frame
#lapply: en el filepath, read all the csv included in selected.files
Data <- lapply(file.path(directory,selected.files),read.csv)
#convert into data frame
#do.call: rbind (rowbind) into a data frame, from al the subdata frames at Data
#do.call bind all the parts in one step
Data <- do.call(rbind.data.frame,Data)
#calculate mean
mean(Data[,pollutant],na.rm=TRUE)
pollutantmean <- function(directory, pollutant, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
#get the file List in that directory
fileList <- list.files(directory)
#extract the file names and store as numeric for comparison
#the sub part: substitute the .csv in every name and just let the number
#the sub part arguments: sustituir \\.csv$", poner "" (en este caso esto es no poner nada), at fileList
#as.numeric: coercion in a number
fileNames <- as.numeric(sub("\\.csv$","",fileList))
#select files to be imported based on the user input or default
#the match part: find id en fileNames, prove using id %in% fileNames
#fileList[] part: subset in fileList where there is a match between id and fileNames
selected.files <- fileList[match(id,fileNames)]
#import data
#lapply: apply a function to all the variables in a data frame
#lapply: en el filepath, read all the csv included in selected.files
Data <- lapply(file.path(directory,selected.files),read.csv)
#convert into data frame
#do.call: rbind (rowbind) into a data frame, from al the subdata frames at Data
#do.call bind all the parts in one step
Data <- do.call(rbind.data.frame,Data)
#calculate mean
mean(Data[,pollutant],na.rm=TRUE)
}
pollutantmean <- function(directory, pollutant, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
#get the file List in that directory
fileList <- list.files(directory)
#extract the file names and store as numeric for comparison
#the sub part: substitute the .csv in every name and just let the number
#the sub part arguments: sustituir \\.csv$", poner "" (en este caso esto es no poner nada), at fileList
#as.numeric: coercion in a number
fileNames <- as.numeric(sub("\\.csv$","",fileList))
#select files to be imported based on the user input or default
#the match part: find id en fileNames, prove using id %in% fileNames
#fileList[] part: subset in fileList where there is a match between id and fileNames
selected.files <- fileList[match(id,fileNames)]
#import data
#lapply: apply a function to all the variables in a data frame
#lapply: en el filepath, read all the csv included in selected.files
Data <- lapply(file.path(directory,selected.files),read.csv)
#convert into data frame
#do.call: rbind (rowbind) into a data frame, from al the subdata frames at Data
#do.call bind all the parts in one step
Data <- do.call(rbind.data.frame,Data)
#calculate mean
mean(Data[,pollutant],na.rm=TRUE)
}
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
pollutantmean <- function(directory, pollutant, id = 1:332) {
#set the path
directory = "/Users/Esteban/Desktop/specdata"
#get the file List in that directory
fileList <- list.files(directory)
#extract the file names and store as numeric for comparison
#the sub part: substitute the .csv in every name and just let the number
#the sub part arguments: sustituir \\.csv$", poner "" (en este caso esto es no poner nada), at fileList
#as.numeric: coercion in a number
fileNames <- as.numeric(sub("\\.csv$","",fileList))
#select files to be imported based on the user input or default
#the match part: find id en fileNames, prove using id %in% fileNames
#fileList[] part: subset in fileList where there is a match between id and fileNames
selected.files <- fileList[match(id,fileNames)]
#import data
#lapply: apply a function to all the variables in a data frame
#lapply: en el filepath, read all the csv included in selected.files
Data <- lapply(file.path(directory,selected.files),read.csv)
#convert into data frame
#do.call: rbind (rowbind) into a data frame, from al the subdata frames at Data
#do.call bind all the parts in one step
Data <- do.call(rbind.data.frame,Data)
#calculate mean
mean(Data[,pollutant],na.rm=TRUE)
}
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
x <- list(a = 1:5, b = rnorm(10))
x
lapply(x, mean)
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))
x
x <- matrix(rnorm(200), 20, 10)
x
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
a
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))
?rep
(rnorm(10), runif(10), rnorm(10, 1))
x <- c(rnorm(10), runif(10), rnorm(10, 1))
x
x <- rnorm(10)
x
f1<-gl(2,5)
f2<-gl(5,2)
str(split(x, list(f1, f2)))
library(datasets)
data(iris)
?iris
iris
f <- gl(3, 50)
f
tapply(iris, f, mean)
apply(iris, c(1,2), mean)
meanquiz <- iris[,1]
meanquiz
f <- gl(3, 50)
f
tapply(meanquiz, f, mean)
colMeans(iris)
apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 2, mean)
apply(iris, 2, mean)
library(datasets)
data(mtcars)
?mtcars
mtcars
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
split(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$hp, mtcars$cyl), mean)
82.63636-209.21429
debug(ls)
ls
exit
ls
ls
ls
debug(ls)
ls
n
M <- matrix(c(1, 2, 3, 4), nrow=2, ncol=2)
M
makeCacheMatrix <- function(x = matrix()) {
cachei <- NULL
set <- function(y) {
x <<- y
cachei <<- NULL
}
get <- function() x
setinverse <- function(inverse) cachei <<- inverse
getinverse <- function() cachei
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
makeCacheMatrix(M)
cacheMatrix <- makeCacheMatrix(M)
cacheMatrix
cacheSolve <- function(x, ...) {
inversef <- x$getInverse()
if(!is.null(inversef)) {
message("getting cached data")
return(inversef)
}
data <- x$get()
inversef <- solve(data, ...)
x$setInverse(inversef)
inversef
}
cacheSolve(M)
M <- matrix(c(1, 2, 3, 4), nrow=2, ncol=2)
cacheMatrix <- makeCacheMatrix(M)
cacheSolve(cacheMatrix)
cacheSolve <- function(x, ...) {
inversef <- x$getInverse()
if(!is.null(inversef)) {
message("getting cached data")
return(inversef)
}
data <- x$get()
inversef <- Inverse(data, ...)
x$setInverse(inversef)
inversef
}
cacheSolve(M)
cacheSolve <- function(x, ...) {
cachei <- x$getinverse()
if(!is.null(cachei)) {
message("getting cached data")
return(cachei)
}
data <- x$get()
cachei <- solve(data, ...)
x$setinverse(cachei)
cachei
}
cacheSolve(M)
makeCacheMatrix <- function(x = matrix()) {
cachei <- NULL
set <- function(y) {
x <<- y
cachei <<- NULL
}
get <- function() x
setInverse <- function(inverse) cachei <<- inverse
getInverse <- function() cachei
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Description of cacheSolve
## Return a new matrix that is the inverse
cacheSolve <- function(x, ...) {
cachei <- x$getInverse()
if(!is.null(cachei)) {
message("getting cached data")
return(cachei)
}
data <- x$get()
cachei <- solve(data, ...)
x$setInverse(cachei)
cachei
}
M <- matrix(c(1, 2, 3, 4), nrow=2, ncol=2)
cacheMatrix <- makeCacheMatrix(M)
cacheSolve(cacheMatrix)
M
M <- matrix(c(1, 2, 3, 4), nrow=2, ncol=2)
## Description of makeCacheMatrix
## cachei <- NULL *set a place for the future vector
## set <- function(y) *define the function
## get <- function() x *return the vector
## setinverse <- function(inverse) *set the inverse matrix
## getinverse <- function() cachei *get the inverse matrix
## list *get a vector with all the functions
makeCacheMatrix <- function(x = matrix()) {
cachei <- NULL
set <- function(y) {
x <<- y
cachei <<- NULL
}
get <- function() x
setInverse <- function(inverse) cachei <<- inverse
getInverse <- function() cachei
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## Description of cacheSolve
## Return a new matrix that is the inverse
cacheSolve <- function(x, ...) {
cachei <- x$getInverse()
if(!is.null(cachei)) {
message("getting cached data")
return(cachei)
}
data <- x$get()
cachei <- solve(data, ...)
x$setInverse(cachei)
cachei
}
cacheMatrix <- makeCacheMatrix(M)
cacheSolve(cacheMatrix)
